<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-eval' 'unsafe-inline' https://cdn.jsdelivr.net https://cdn.skypack.dev blob:; worker-src 'self' blob:; connect-src 'self' https://cdn.jsdelivr.net https://cdn.skypack.dev blob: wss://cs16-p2p.up.railway.app https://cs16-p2p.up.railway.app;">
    <title>CS 1.6</title>
    <script src="coi-serviceworker.js"></script>
    <style>
        canvas { width: 100vw; height: 100vh; top: 0; left: 0; position: fixed; }
        body { margin: 0; background: black; }
        #status { color: white; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-family: monospace; font-size: 18px; z-index: 10; text-align: center; }
        #lobby {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            position: fixed; inset: 0; background: #111; z-index: 20;
            font-family: monospace; color: white; gap: 16px;
        }
        #lobby h2 { margin: 0; font-size: 24px; letter-spacing: 2px; color: #f90; }
        #lobby input {
            padding: 8px 12px; font-size: 18px; font-family: monospace;
            background: #222; border: 1px solid #555; color: white; width: 200px; text-align: center;
        }
        #lobby button {
            padding: 10px 28px; font-size: 16px; font-family: monospace;
            background: #f90; border: none; color: black; cursor: pointer; font-weight: bold;
        }
        #lobby button:hover { background: #ffb733; }
        #lobby .row { display: flex; gap: 12px; }
        #lobby .hint { color: #888; font-size: 13px; }
        #host-id-display { display: none; color: #0f0; font-size: 22px; letter-spacing: 4px; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/xash3d-fwgs@latest/dist/raw.js"></script>
</head>
<body>

<!-- Lobby UI shown before game starts -->
<div id="lobby">
    <h2>CS 1.6 MULTIPLAYER</h2>

    <div id="host-section">
        <button id="btn-host">HOST GAME</button>
        <div id="host-id-display">Your ID: <span id="host-id-value"></span></div>
        <div class="hint" id="host-hint" style="display:none">Share this ID with friends, then press START</div>
        <button id="btn-start" style="display:none">START GAME</button>
    </div>

    <div style="color:#555">— or —</div>

    <div id="join-section">
        <div class="row">
            <input id="join-id" type="number" placeholder="Host ID" min="1" />
            <button id="btn-join">JOIN</button>
        </div>
        <div class="hint">Enter the host's ID number</div>
    </div>
</div>

<div id="status" style="display:none">Loading...</div>
<canvas id="canvas"></canvas>

<script type="module">
    import JSZip from 'https://cdn.skypack.dev/jszip@3.10.1';

    // ─── CONFIG ──────────────────────────────────────────────────────────────
    const SIGNAL_URL = 'wss://cs16-p2p.up.railway.app/hl'; // <-- replace this
    const CDN  = 'https://cdn.jsdelivr.net/npm/xash3d-fwgs@latest/dist/';
    const CS16 = 'https://cdn.jsdelivr.net/npm/cs16-client@latest/dist/cstrike/';

    const iceServers = [
        { urls: 'stun:stun.relay.metered.ca:80' },
        { urls: 'turn:standard.relay.metered.ca:80',              username: '775036bccfb97412ac56ae8a', credential: 'S0nMcJRAuceCFQqK' },
        { urls: 'turn:standard.relay.metered.ca:80?transport=tcp', username: '775036bccfb97412ac56ae8a', credential: 'S0nMcJRAuceCFQqK' },
        { urls: 'turn:standard.relay.metered.ca:443',              username: '775036bccfb97412ac56ae8a', credential: 'S0nMcJRAuceCFQqK' },
        { urls: 'turns:standard.relay.metered.ca:443?transport=tcp', username: '775036bccfb97412ac56ae8a', credential: 'S0nMcJRAuceCFQqK' },
    ];
    // ─────────────────────────────────────────────────────────────────────────

    const status  = document.getElementById('status');
    const lobby   = document.getElementById('lobby');

    // State set by lobby UI before game starts
    let myHostId    = null;   // assigned by server
    let joinTargetId = null;  // set if joining someone else

    // ── Lobby UI ─────────────────────────────────────────────────────────────
    let sigSocket = null;
    let sigReady  = false;

    function connectSignaling() {
        return new Promise((resolve, reject) => {
            sigSocket = new WebSocket(SIGNAL_URL);
            sigSocket.onmessage = e => {
                const msg = JSON.parse(e.data);
                if (msg.hostId !== undefined) {
                    myHostId = msg.hostId;
                    resolve(msg.hostId);
                }
            };
            sigSocket.onerror = reject;
        });
    }

    document.getElementById('btn-host').onclick = async () => {
        document.getElementById('btn-host').disabled = true;
        document.getElementById('btn-host').textContent = 'Connecting...';
        try {
            const id = await connectSignaling();
            document.getElementById('host-id-value').textContent = id;
            document.getElementById('host-id-display').style.display = 'block';
            document.getElementById('host-hint').style.display = 'block';
            document.getElementById('btn-start').style.display = 'inline-block';
            document.getElementById('btn-host').style.display = 'none';
        } catch(e) {
            alert('Could not connect to signaling server: ' + e);
            document.getElementById('btn-host').disabled = false;
            document.getElementById('btn-host').textContent = 'HOST GAME';
        }
    };

    document.getElementById('btn-start').onclick = () => {
        lobby.style.display = 'none';
        status.style.display = 'block';
        startGame();
    };

    document.getElementById('btn-join').onclick = async () => {
        const id = parseInt(document.getElementById('join-id').value);
        if (!id) return alert('Enter a valid host ID');
        joinTargetId = id;
        document.getElementById('btn-join').disabled = true;
        document.getElementById('btn-join').textContent = 'Connecting...';
        try {
            await connectSignaling();
            lobby.style.display = 'none';
            status.style.display = 'block';
            startGame();
        } catch(e) {
            alert('Could not connect to signaling server: ' + e);
            document.getElementById('btn-join').disabled = false;
            document.getElementById('btn-join').textContent = 'JOIN';
        }
    };

    // ── VirtualNetworkWrapper (adapted from turch.in) ─────────────────────────
    // Injected into Emscripten module via preRun, replaces UDP socket syscalls
    // with WebRTC DataChannels routed through our signaling server.
    function VirtualNetworkWrapper(module) {
        const peers    = new Map();   // key -> RTCPeerConnection
        const channels = new Map();   // fdescriptor -> RTCDataChannel
        const sockets  = new Map();
        const send_queue = new Map(); // "addr:port" -> queued packets
        const recv_queue = [];        // { addr, data }

        const ws = sigSocket; // reuse already-open signaling socket

        // Handle incoming signaling messages (offers/answers/ICE from peers)
        ws.addEventListener('message', async e => {
            const msg = JSON.parse(e.data);
            if (msg.hostId !== undefined) return; // already handled

            if (msg['pc:offer']) {
                const { description, from } = msg['pc:offer'];
                const pc = new RTCPeerConnection({ iceServers });
                peers.set(`${myHostId}:${from}`, pc);

                pc.addEventListener('datachannel', ({ channel }) => {
                    channel.addEventListener('open', () => channels.set(from, channel));
                    channel.addEventListener('message', async ({ data }) =>
                        recv_queue.push({
                            addr: `101.101.${from & 255}.${(from >> 8) & 255}`,
                            port: 27015,
                            data: data instanceof Blob ? await data.arrayBuffer() : data
                        })
                    );
                    channel.addEventListener('close', () => channels.delete(from));
                });

                pc.addEventListener('icecandidate', ({ candidate }) => {
                    if (candidate) ws.send(JSON.stringify({ 'pc:ice-candidate': { candidate, from: myHostId, to: from } }));
                });

                await pc.setRemoteDescription(description);
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                ws.send(JSON.stringify({ 'pc:answer': { description: pc.localDescription, from: myHostId, to: from } }));
                return;
            }

            if (msg['pc:answer']) {
                const { description, from } = msg['pc:answer'];
                const pc = peers.get(`${myHostId}:${from}`);
                if (pc) await pc.setRemoteDescription(description);
                return;
            }

            if (msg['pc:ice-candidate']) {
                const { candidate, from } = msg['pc:ice-candidate'];
                const pc = peers.get(`${myHostId}:${from}`);
                if (pc) await pc.addIceCandidate(candidate);
                return;
            }
        });

        function createConnection(targetId, onReady) {
            const addrStr = `101.101.${targetId & 255}.${(targetId >> 8) & 255}`;
            const peerKey = `${myHostId}:${targetId}`;

            const pc = new RTCPeerConnection({ iceServers });
            const channel = pc.createDataChannel(addrStr, { maxRetransmits: 0, ordered: false });

            channel.addEventListener('open', () => {
                channels.set(targetId, channel);
                // flush queued packets
                const q = send_queue.get(`${addrStr}:27015`) || [];
                while (q.length) channel.send(q.shift());
                onReady?.();
            });
            channel.addEventListener('message', async ({ data }) =>
                recv_queue.push({
                    addr: addrStr,
                    port: 27015,
                    data: data instanceof Blob ? await data.arrayBuffer() : data
                })
            );
            channel.addEventListener('close', () => channels.delete(targetId));

            peers.set(peerKey, pc);

            pc.addEventListener('icecandidate', ({ candidate }) => {
                if (candidate) ws.send(JSON.stringify({ 'pc:ice-candidate': { candidate, from: myHostId, to: targetId } }));
            });
            pc.addEventListener('connectionstatechange', () => {
                if (pc.connectionState === 'failed') {
                    onReady?.(pc.connectionState);
                    pc.restartIce();
                }
                if (pc.connectionState === 'closed' || pc.connectionState === 'disconnected') {
                    peers.delete(peerKey);
                }
            });

            pc.createOffer()
              .then(d => pc.setLocalDescription(d))
              .then(() => ws.send(JSON.stringify({
                  'pc:offer': { description: pc.currentLocalDescription ?? pc.localDescription, from: myHostId, to: targetId }
              })));
        }

        // preConnectToServer: called by game code to connect to a specific peer
        module.preConnectToServer = targetId => new Promise((resolve, reject) => {
            createConnection(targetId, err => err ? reject(err) : resolve());
        });

        // Expose hostId and net syscall overrides to the engine
        module.net = {
            getHostId: () => myHostId,

            recvfrom: (fd, buf, len, flags, addrPtr, addrLenPtr) => {
                const pkt = recv_queue.shift();
                if (!pkt) {
                    module.setValue(module.___errno_location(), 73, 'i32'); // EAGAIN
                    return -1;
                }
                module.writeSockaddr(addrPtr, 2, pkt.addr, pkt.port, addrLenPtr);
                module.HEAPU8.set(new Uint8Array(pkt.data), buf);
                return pkt.data.byteLength;
            },

            sendto: (fd, buf, len, flags, addrPtr, addrLen) => {
                const dst  = module.readSockaddr(addrPtr, addrLen);
                const data = module.HEAPU8.subarray(buf, buf + len);
                if (dst.addr === '255.255.255.255') return data.length; // broadcast, ignore

                const [,, b3, b4] = dst.addr.split('.').map(Number);
                const targetId = b3 | (b4 << 8);
                const peerKey  = `${myHostId}:${targetId}`;

                if (peers.has(peerKey) && channels.has(targetId)) {
                    channels.get(targetId).send(data);
                    return data.length;
                }

                // Queue packet and start connecting if not already
                const qKey = `${dst.addr}:${dst.port}`;
                if (!send_queue.has(qKey)) {
                    send_queue.set(qKey, []);
                    createConnection(targetId, null);
                }
                send_queue.get(qKey).push(data.slice());
                return data.length;
            },
        };
    }

    // ── Game boot ─────────────────────────────────────────────────────────────
    async function startGame() {
        const chunkUrls = [
            './valve.zip.part1', './valve.zip.part2', './valve.zip.part3',
            './valve.zip.part4', './valve.zip.part5', './valve.zip.part6',
        ];

        status.textContent = 'Downloading game chunks...';
        const chunks = await Promise.all(
            chunkUrls.map((url, i) =>
                fetch(url).then(async r => {
                    if (!r.ok) throw new Error(`Chunk ${i + 1} not found`);
                    return r.arrayBuffer();
                })
            )
        );

        status.textContent = 'Merging chunks...';
        const totalLength = chunks.reduce((sum, c) => sum + c.byteLength, 0);
        const merged = new Uint8Array(totalLength);
        let offset = 0;
        for (const chunk of chunks) { merged.set(new Uint8Array(chunk), offset); offset += chunk.byteLength; }

        status.textContent = 'Extracting zip...';
        const zip = await JSZip.loadAsync(merged);
        const files = {};
        await Promise.all(Object.keys(zip.files).map(async p => {
            const file = zip.files[p];
            if (file.dir) return;
            files[`/rodir/${p}`] = await file.async('uint8array');
        }));

        status.textContent = 'Starting game...';

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('webgl2', {
            alpha: false, depth: true, stencil: true, antialias: false,
            powerPreference: 'high-performance', preserveDrawingBuffer: true,
            failIfMajorPerformanceCaveat: false
        });

        Xash3D({
            arguments: ['-windowed', '-game', 'cstrike', '+_vgui_menus', '0', '-ref', 'webgl2',
                        '+bot_quota', '0', '+bot_join_after_player', '0', '+bot_difficulty', '1'],
            canvas,
            ctx,
            dynamicLibraries: [
                'filesystem_stdio.wasm', 'libref_webgl2.wasm',
                'cl_dlls/menu_emscripten_wasm32.wasm',
                'dlls/cs_emscripten_wasm32.wasm',
                'cl_dlls/client_emscripten_wasm32.wasm',
                '/rwdir/filesystem_stdio.so',
            ],
            preRun: [
                // Inject P2P networking before engine starts
                function(module) {
                    VirtualNetworkWrapper(module);

                    // If joining, auto-connect to host after engine init
                    if (joinTargetId !== null) {
                        const origInit = module.onRuntimeInitialized;
                        module.onRuntimeInitialized = function() {
                            origInit?.call(this);
                            const ip = `101.101.${joinTargetId & 255}.${(joinTargetId >> 8) & 255}`;
                            setTimeout(() => {
                                module.preConnectToServer(joinTargetId).then(() => {
                                    module.executeString?.(`connect ${ip}`);
                                });
                            }, 2000);
                        };
                    }
                }
            ],
            onRuntimeInitialized: function () {
                Object.entries(files).forEach(([k, v]) => {
                    const dir = k.split('/').slice(0, -1).join('/');
                    this.FS.mkdirTree(dir);
                    this.FS.writeFile(k, v);
                });
                this.FS.chdir('/rodir');
                status.style.display = 'none';
            },
            locateFile: (p) => {
                switch (p) {
                    case 'xash.wasm':                           return CDN + 'xash.wasm';
                    case 'filesystem_stdio.wasm':
                    case '/rwdir/filesystem_stdio.so':          return CDN + 'filesystem_stdio.wasm';
                    case 'libref_webgl2.wasm':                  return CDN + 'libref_webgl2.wasm';
                    case 'libref_soft.wasm':                    return CDN + 'libref_soft.wasm';
                    case 'cl_dlls/menu_emscripten_wasm32.wasm': return CS16 + 'cl_dlls/menu_emscripten_wasm32.wasm';
                    case 'dlls/cs_emscripten_wasm32.wasm':      return CS16 + 'dlls/cs_emscripten_wasm32.wasm';
                    case 'cl_dlls/client_emscripten_wasm32.wasm': return CS16 + 'cl_dlls/client_emscripten_wasm32.wasm';
                    default: return p;
                }
            },
        });
    }

    main().catch(e => {
        status.textContent = 'Error: ' + e.message;
        console.error(e);
    });

    // Kick off lobby (don't start game yet)
    function main() { return Promise.resolve(); }
</script>
</body>
</html>
